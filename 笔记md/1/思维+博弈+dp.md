**有k个玻璃珠，楼高度为n，设扔下去摔碎的楼层为ans，小于ans的楼层不碎，大于等于的碎。问保证求出ans前提下，最小扔多少次（LeetCode）**

1. 如果玻璃珠无限，二分
2. 如果只有两个玻璃珠，分块。分为$\sqrt{n}$，每块遍历$\sqrt{n}$,但实际上最后$\sqrt{n}$个的时候，仍有两个，可考虑2分。n=100时，ans=19
3. k非无穷情况：dp。$dp[n][k]=min(dp[x-1][k-1],dp[n-x][k])+1$.

   这是总共有n层楼，答案在n层楼里面最大那个的最小值

   因此要自己决定这个碎还是不碎，可以更大变化答案

   前一项是第x层碎，那么就只用检查剩下x-1，并且要花费珠子。如果珠子不够，

   后一项是第x层不碎，那么检查另一边n-x

   考虑边界：第0层=0，第1层=1，珠子为1的时候只能为高度x。算法时间复杂度O(nkn)


**询问数轴上移动t格，从原点出发左右两侧都有点。最多能到达多少个点：**

​	<https://www.luogu.com.cn/problem/P2390>

1. 枚举左端点，减掉去左端点的时间后，再二分答案找右端点

2. 二分经过的点数，然后枚举每个左端点，那么右=左+点数。然后如果两个端点在一侧，那就远的那个在t以内。如果夹着，那就去近的那一个+二者距离差<=t

**假设cpu可以同时处理k个任务，只要任务一结束就会立刻换新的进来直到没任务。任务必须按顺序执行，给出所有的任务时间ti和最晚全部处理时间T，求k的最小值：**<https://www.luogu.com.cn/problem/P3611>

​	二分k，然后优先队列，每次取出最早的那个，把now变为那一刻出去的时间。然后推入新的任务，时间为当前时间+完成时间。

