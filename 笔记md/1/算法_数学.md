**组合数学：n球m盒子**

球同代表可以隔板，因为交换球的位置仍相同，交换球的位置并没有意义

盒子同代表可以交换盒子位置，那么可以去重

1.球同、盒不同、不能空：

```
n-1个空隙要插m-1个板，c(n-1,m-1)
```

2.球同、盒不同、能空：

```
直接假设已经给每个盒子一个球，转化为1
c(n+m-1,m-1)
```

问：有m张卡，放回抽取，抽n次，然后每张卡至少抽到一张的概率

```
相当于将n个相同的球扔进m个不同盒子
那么就是上面的情况1/情况2,展开直接算阶乘是o(n)
```

3.球不同，盒同，不能空

```
首先dp[i][i]=1,dp[i][0]=0;//i个球，j个盒子
然后dp[i][j]=j*dp[i-1][j]+dp[i-1][j-1]，放在已有的盒子或者放新盒子
```

4.球不同，盒同，能空

```
处理出3，答案等于dp[n][1]+dp[n][2]+……+dp[n][m]
```

5.球不同、盒不同、不能空

```
第三种对盒子全排列,m!*dp[n][m]
```

6.球不同，盒不同，能空

```
就是球任意m放法，m^n
```

**鸽巢：**

n个球m个盒，恰好n-1个盒子有球，球不同盒不同

```
 即恰好有n-2个盒子各1个球，1个盒子2个球
 后者从m中挑1个盒子，前者从m-1挑n-1个盒子，然后隔n-2个板
 球不同，因此要排列，为n!，其中2个球的盒子不考虑排列，因此/2!
```

**秦九韶算法：**

```
for(int i=n;i>=0;i--)sum=sum*x+a[i];//其中a[i]为多项式系数
```

**六步筛：**

```
>5时，质数只会出现在6的倍数的左右。
出现在6的左右但不是质数，只有是6左右的数的倍数
```

```
bool pri(int x){
	if(x==1)return false;
	if(x==2 or x==3)return true;
	if((x+1)%6 and (x-1)%6)return false;
	int t=sqrt(x);
	for(int i=5;i<=t;i+=6){//不可以写成从6开始，否则35会失败 
		if(x%(i)==0 or x%(i+2)==0)return false;
	}
	return true;
}
```

**欧拉筛：**

```
使用bitset记录第i个数是不是质数
用pr(prime)数组记录质数表，用lp数组记录i可以分解出的最小非1质数
博弈思想：没有筛掉的必然是胜（质数），并且他的最小分解是自身
```

```
const int maxn=1e6+8;
bitset<maxn>p;
int pr[maxn],lp[maxn];//质数表，以及对应可以分解的最小非1质数 
void ol(){
	int k=0;
	p.set();
	p[1]=false;
	for(int i=2;i<=maxn-7;i++){
		if(p[i]){
			pr[++k]=i;//没有被筛掉
			lp[i]=i;
		}
		for(int j=1;j<=k and i*pr[j]<=maxn;j++){//用i去筛素数 
			p[i*pr[j]]=false;
			lp[i*pr[j]]=pr[j];
			if(i%pr[j]==0)break;
			//新质数包括旧质数，那么旧质数刷掉的数，一定把这个新质数刷的也包含呃
		} 
	}
}
```

**分解质数：**

```
对于n，可以只分解到根号n，如果分解完后剩余不是1，那么剩余且只剩余一个大于根号n的质数
```

**exgcd:**

```
对于ax+by=gcd(a,b)，我们能求出满足gcd(x,y)最大值的x和y
```
